(in-package :gml)

(declaim (optimize (debug 0) (space 0) (speed 3)))

(defvar *tolerance* 1e-7)

(deftype vec () '(simple-array single-float (3)))
(defstruct (vec
             (:type (vector single-float))
             (:constructor %vec (&optional x y z))
             (:copier vcp)
             (:conc-name v))
  (x 0.0 :type single-float)
  (y 0.0 :type single-float)
  (z 0.0 :type single-float))

(declaim (ftype (function (&optional number number number) vec) vec))
(declaim (inline vec))
(defun vec (&optional (x 0.0) (y 0.0) (z 0.0))
  (%vec (float x 1.0) (float y 1.0) (float z 1.0)))

(defmacro %with-vector ((prefix vec) &body body)
  (let ((*package* (find-package :gml)))
    `(with-accessors ((,(symbolicate prefix "X") vx)
                      (,(symbolicate prefix "Y") vy)
                      (,(symbolicate prefix "Z") vz))
       ,vec
       ,@body)))

(defmacro %with-vectors (binds &body body)
  (if (null binds)
    `(progn ,@body)
    `(%with-vector
       ,(car binds)
       (%with-vectors ,(cdr binds) ,@body))))

(declaim (ftype (function (vec &key (:tolerance single-float)) vec) vstab!))
(defun vstab! (src &key (tolerance *tolerance*))
  (%with-vector (s src)
    (macrolet ((stabilize (place)
                 `(when (< (abs ,place) tolerance)
                    (setf ,place 0.0))))
      (stabilize sx)
      (stabilize sy)
      (stabilize sz)))
  src)

(declaim (ftype (function (vec &key (:tolerance single-float)) vec) vstab))
(defun vstab (src &key (tolerance *tolerance*))
  (vstab! (vcp src) :tolerance tolerance))

(declaim (ftype (function (vec vec) vec) vcp!))
(declaim (inline vcp!))
(defun vcp! (src dest)
  (%with-vectors ((s src) (d dest))
    (psetf dx sx
           dy sy
           dz sz))
  dest)

(declaim (ftype (function (vec) vec) vclr!))
(declaim (inline vclr!))
(defun vclr! (src)
  (%with-vector (s src)
    (psetf sx 0.0
           sy 0.0
           sz 0.0))
  src)

(declaim (ftype (function (vec) list) vlist))
(declaim (inline vlist))
(defun vlist (src)
  (%with-vector (s src)
    (list sx sy sz)))

(declaim (ftype (function (vec vec vec) vec) v+!))
(declaim (inline v+!))
(defun v+! (src1 src2 dest)
  (%with-vectors ((s1 src1) (s2 src2) (d dest))
    (psetf dx (+ s1x s2x)
           dy (+ s1y s2y)
           dz (+ s1z s2z)))
  dest)

(declaim (ftype (function (vec vec) vec) v+))
(defun v+ (src1 src2)
  (v+! src1 src2 (vec)))

(declaim (ftype (function (vec vec vec) vec) v-!))
(declaim (inline v-!))
(defun v-! (src1 src2 dest)
  (%with-vectors ((s1 src1) (s2 src2) (d dest))
    (psetf dx (- s1x s2x)
           dy (- s1y s2y)
           dz (- s1z s2z)))
  dest)

(declaim (ftype (function (vec vec) vec) v-))
(defun v- (src1 src2)
  (v-! src1 src2 (vec)))

(declaim (ftype (function (vec vec vec) vec) v*!))
(declaim (inline v*!))
(defun v*! (src1 src2 dest)
  (%with-vectors ((s1 src1) (s2 src2) (d dest))
    (psetf dx (* s1x s2x)
           dy (* s1y s2y)
           dz (* s1z s2z)))
  dest)

(declaim (ftype (function (vec vec) vec) v*))
(defun v* (src1 src2)
  (v*! src1 src2 (vec)))

(declaim (ftype (function (vec single-float) vec) vscale!))
(declaim (inline vscale!))
(defun vscale! (src scalar)
  (%with-vector (s src)
    (psetf sx (* sx scalar)
           sy (* sy scalar)
           sz (* sz scalar)))
  src)

(declaim (ftype (function (vec single-float) vec) vscale))
(defun vscale (src scalar)
  (vscale! (vcp src) scalar))

(declaim (ftype (function (vec) single-float) vlen))
(declaim (inline vlen))
(defun vlen (src)
  (%with-vector (s src)
    (sqrt (+ (* sx sx)
             (* sy sy)
             (* sz sz)))))

(declaim (ftype (function (vec) vec) vnorm!))
(defun vnorm! (src)
  (let ((magnitude (vlen src)))
    (unless (zerop magnitude)
      (%with-vector (s src)
        (psetf sx (/ sx magnitude)
               sy (/ sy magnitude)
               sz (/ sz magnitude))))
    src))

(declaim (ftype (function (vec) vec) vnorm))
(defun vnorm (src)
  (vnorm! (vcp src)))

(declaim (ftype (function (vec) vec) vround!))
(defun vround! (src)
  (%with-vector (s src)
    (psetf sx (float (floor (+ sx 1/2)) 1.0)
           sy (float (floor (+ sy 1/2)) 1.0)
           sz (float (floor (+ sz 1/2)) 1.0)))
  src)

(declaim (ftype (function (vec) vec) vround))
(defun vround (src)
  (vround! (vcp src)))

(declaim (ftype (function (vec) vec) vpos!))
(declaim (inline vpos!))
(defun vpos! (src)
  (%with-vector (s src)
    (psetf sx (abs sx)
           sy (abs sy)
           sz (abs sz)))
  src)

(declaim (ftype (function (vec) vec) vpos))
(defun vpos (src)
  (vpos! (vcp src)))

(declaim (ftype (function (vec) vec) vneg!))
(declaim (inline vneg!))
(defun vneg! (src)
  (%with-vector (s src)
    (psetf sx (- sx)
           sy (- sy)
           sz (- sz)))
  src)

(declaim (ftype (function (vec) vec) vneg))
(defun vneg (src)
  (vneg! (vcp src)))

(declaim (ftype (function (vec) vec) vrev!))
(declaim (inline vrev!))
(defun vrev! (src)
  (vscale! src -1.0))

(declaim (ftype (function (vec) vec) vrev))
(defun vrev (src)
  (vrev! (vcp src)))

(declaim (ftype (function (vec vec vec) vec) vcross!))
(declaim (inline vcross!))
(defun vcross! (src1 src2 dest)
  (%with-vectors ((s1 src1) (s2 src2) (d dest))
    (psetf dx (- (* s1y s2z) (* s1z s2y))
           dy (- (* s1z s2x) (* s1x s2z))
           dz (- (* s1x s2y) (* s1y s2x))))
  dest)

(declaim (ftype (function (vec vec) vec) vcross))
(defun vcross (src1 src2)
  (vcross! src1 src2 (vec)))

(declaim (ftype (function (vec vec) single-float) vdot))
(declaim (inline vdot))
(defun vdot (src1 src2)
  (%with-vectors ((s1 src1) (s2 src2))
    (+ (* s1x s2x)
       (* s1y s2y)
       (* s1z s2z))))

(declaim (ftype (function (vec vec vec) single-float) vbox))
(defun vbox (src1 src2 src3)
  (vdot (vcross src1 src2) src3))

(declaim (ftype (function (vec vec) single-float) vdist))
(declaim (inline vdist))
(defun vdist (src1 src2)
  (%with-vectors ((s1 src1) (s2 src2))
    (sqrt (+ (expt (- s2x s1x) 2)
             (expt (- s2y s1y) 2)
             (expt (- s2z s1z) 2)))))

(declaim (ftype (function (vec vec single-float &optional boolean) vec) vtrans!))
(defun vtrans! (src direction distance &optional normalizep)
  (when normalizep
    (vnorm! direction))
  (v+! src (vscale! direction distance) src))

(declaim (ftype (function (vec vec single-float &optional boolean) vec) vtrans))
(defun vtrans (src direction distance &optional normalizep)
  (vtrans! (vcp src) direction distance normalizep))

(declaim (ftype (function (vec) boolean) vzerop))
(declaim (inline vzerop))
(defun vzerop (src)
  (%with-vector (s (vstab src))
    (and (zerop sx)
         (zerop sy)
         (zerop sz))))

(declaim (ftype (function (vec vec &key (:tolerance single-float)) boolean) vclosep))
(defun vclosep (src1 src2 &key (tolerance *tolerance*))
  (< (vdist src1 src2) tolerance))

(declaim (ftype (function (vec vec) boolean) vdirp))
(defun vdirp (src1 src2)
  (and (not (or (vzerop src1) (vzerop src2)))
       (vclosep (vnorm! src1) (vnorm! src2))))

(declaim (ftype (function (vec vec) boolean) vparp))
(defun vparp (src1 src2)
  (or (vdirp src1 src2)
      (vdirp src1 (vrev src2))))

(declaim (ftype (function (vec) boolean) vplusp))
(declaim (inline vplusp))
(defun vplusp (src)
  (%with-vector (s src)
    (or (plusp sx)
        (plusp sy)
        (plusp sz))))

(declaim (ftype (function (vec) boolean) vminusp))
(declaim (inline vminusp))
(defun vminusp (src)
  (%with-vector (s src)
    (or (minusp sx)
        (minusp sy)
        (minusp sz))))

(defun %vector-test ()
  (time
    (loop with v = (vec)
          repeat 1000000
          do (v*! v v v))))
