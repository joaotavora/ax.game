(in-package :gml)

(defun move-by (vec mat &key continuep)
  (unless (vzerop vec)
    (m*! (mtrans vec) mat mat)
    (unless continuep
      (vclr! vec))))

(defun rotate-by (vec mat &key continuep)
  (unless (vzerop vec)
    (mrot! vec mat mat)
    (unless continuep
      (vclr! vec))))

(defun rpms->radians (rotation dt)
  (flet ((radians (rpms)
           (* (/ (* rpms 2 pi) 60) dt)))
    (apply #'vec (map 'list #'radians rotation))))

(defun set-direction (direction)
  (loop with i = 0
        with start = (/ (* pi 2) -12)
        with inc = (/ (* pi 2) 6)
        with result = (vec)
        for d in '(:ne :e :se :sw :w :nw)
        for z = (+ start (* inc (- i)))
        do (incf i)
           (when (eq d direction)
             (setf (vz result) (float z 1.0)))
        finally (return result)))

(defun get-angle (dir forward left)
  (let ((angle (atan (vlen (vcross dir forward)) (vdot dir forward))))
    (if (plusp (vdot dir left))
      (- angle)
      angle)))

(defun line-direction (start end)
  (vnorm (v- end start)))

(defun line-midpoint (start end)
  (vtrans start (line-direction start end) (/ (vdist start end) 2)))

(defun line-plane-intersect (line-start line-end plane-point plane-normal)
  (let* ((direction (v- line-start line-end))
         (dot-dir-plane (vdot direction plane-normal))
         (plane-line (v- line-start plane-point)))
    (if (zerop dot-dir-plane)
      (vec)
      (let ((p (/ (- (vdot plane-normal plane-line)) dot-dir-plane)))
        (vtrans line-start direction p)))))

(defun point-line-distance (start end point)
  (let* ((direction (line-direction start end))
         (intersect (line-plane-intersect start end point direction)))
    (vdist point intersect)))

(defun frustum-planes (view-projection)
  (%with-matrix (m view-projection)
    (let* ((r1 (vec m00 m10 m20))
           (r2 (vec m01 m11 m21))
           (r3 (vec m02 m12 m22))
           (r4 (vec m03 m13 m23))
           (left (v+ r4 r1))
           (left-normal (vnorm left))
           (left-dir (/ (+ m33 m30) (vlen left)))
           (right (v- r4 r1))
           (right-normal (vnorm right))
           (right-dir (/ (- m33 m30) (vlen right)))
           (bottom (v+ r4 r2))
           (bottom-normal (vnorm bottom))
           (bottom-dir (/ (+ m33 m31) (vlen bottom)))
           (top (v- r4 r2))
           (top-normal (vnorm top))
           (top-dir (/ (- m33 m31) (vlen top)))
           (near (v+ r4 r3))
           (near-normal (vnorm near))
           (near-dir (/ (+ m33 m32) (vlen near)))
           (far (v- r4 r3))
           (far-normal (vnorm far))
           (far-dir (/ (- m33 m32) (vlen far))))
      (values (vector left-normal right-normal bottom-normal top-normal near-normal far-normal)
              (vector left-dir right-dir bottom-dir top-dir near-dir far-dir)))))

(defun point-in-frustum-p (point frustum-normals frustum-distances &optional (radius 0))
  (loop with i = 0
        for normal across frustum-normals
        for distance = (+ (vdot normal point) (aref frustum-distances i))
        do (when (< distance (- radius))
             (return nil))
        (incf i)
        finally (return t)))
